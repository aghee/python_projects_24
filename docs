#PEP8--comments max 79 characters,code max 72 characters
#Customized simple explanations collected as i learn python

----------------------OOP-----------------------------------------------------------------------------------------------------------
__init__() method -python calls this method by default everytime you create an object, it creates space in computer memory for the object
Any time a .py file is run and interpreted, certain variables are set up and linked with the file. 
This includes __main__ environment variable, which is assigned as the file’s __name__ variable.
Object
-Variables that contain data and functions that can be used to manipulate the data
-The object's data can vary in type (string, integer, etc.) depending on how it's been defined.
-An object is like a mini-program inside python, with its own set of rules and behaviors
Constructors
-used to initialize class instance variables and make sure the object is created in a usable state
Class variables
-defined within a class but outside any of the class's methods
Instance variable
-Are owned by instances of the class. This means that for each object or instance of a class, the instance variables are different.
-Unlike class variables, instance variables are defined within methods
-An instance variable (e.g.: when using the self. prefix) is data that is associated with a specific instance of an object.
Data members
-A class variable or instance variable that holds data associated with a class and its objects
Function overloading 
−The assignment of more than one behavior to a particular function.

29.01.2024

Scope

-The scope of a name is the region of a program in which that name has meaning. The interpreter determines this at runtime based on where the name definition occurs and where in the code the name is referenced.

Variable scope

-The existence of multiple, distinct namespaces means several different instances of a particular name can exist simultaneously while a Python program runs. As long as each instance is in a different namespace, they’re all maintained separately and won’t interfere with one another.

QN: Suppose you refer to the name x in your code, and x exists in several namespaces. How does Python know which one you mean?

ANSWER: If your code refers to the name x, then Python searches for x in the following namespaces in the order shown: LEGB rule

1.Local: If you refer to x inside a function, then the interpreter first searches for it in the innermost scope that’s local to that function.

2.Enclosing: If x isn’t in the local scope but appears in a function that resides inside another function, then the interpreter searches in the enclosing function’s scope.

3.Global: If neither of the above searches is fruitful, then the interpreter looks in the global scope next.

4.Built-in: If it can’t find x anywhere else, then the interpreter tries the built-in scope.

The interpreter searches for a name from the inside out, looking in the local, enclosing, global, and finally the built-in scope.If the interpreter doesn’t find the name in any of these locations, then Python raises a NameError exception.
Namespaces-

-a collection of currently defined symbolic names along with information about the object that each name references. You can think of a namespace as a dictionary in which the keys are the object names and the values are the objects themselves. Each key-value pair maps a name to its corresponding object. Types of namespaces- Builtin,global,enclosing, local.

-As Python executes a program, it creates namespaces as necessary and deletes them when they’re no longer needed. Typically, many namespaces will exist at any given time.

-nonlocal keyword-Names specified after the nonlocal keyword refer to variables in the nearest enclosing scope

-global keyword

Code Example

#Namespaces and scope

def scope_test():

    spam = "test spam" #enclosing scope

    def do_local():

        spam = "local spam" #local scope

    def do_nonlocal():

        nonlocal spam #Names specified after the nonlocal keyword refer to variables in the nearest enclosing scope

        spam = "nonlocal spam"

    def do_global():

        global spam

        spam = "global spam" #global scope

    do_local()

    print("After local assignment:", spam)# output:After local assignment: test spam???--LEGB(local>enclosing>global>built-in)

    do_nonlocal()

    print("After nonlocal assignment:", spam)#output:After nonlocal assignment: nonlocal spam

    do_global()

    print("After global assignment:", spam)#output: After global assignment: nonlocal spam
scope_test()

print("In global scope:", spam)#output:In global scope: global spam


**object can call method

object can call attribute

class_name.method_name(object_name) same output as object_name.method()

self- refers to the instance of the class that is currently being used,self is always pointing to the Current Object.Whenever you call a method of an object created from a class, the object is automatically passed as the first argument using the “self” parameter. This enables you to modify the object’s properties and execute tasks unique to that particular instance.

In a class having many objects, each of the objects have different self which contain their attributes.

NOTE: Self is a convention and not a Python keyword. Self is a parameter in Instance Method and the user can use another parameter name in place of it. But it is advisable to use self because it increases the readability of code, and it is also a good programming practice.

Instance-single occurence of sth

Class-collection of objects

Object-instance of a class, an entity that has a state and behavior associated with it.

An object consists of:

State- attributes of an object,properties of an object eg breed,age,color

Behaviour-methods of an object,response of an object to other objects eg eats,sleeps

Identity-name of the object eg name of dog

__init__ constructor- run as soon as an object of a class is instantiated.The method is useful to do any initialization you want to do with your object.

Example code

class Dog:


    # class attribute -shared by all instances of the class

    attr1 = "mammal"


    # Instance attribute

    #name parameter is used to assign a name attribute to each instance of Dog.

    def __init__(self, name):#initializes an instance of the Dog class

        self.name = name

# Driver code

# Object instantiation. The __init__ method is called for each instance to initialize their name attributes with the provided names.

Rodger = Dog("Rodger")

Tommy = Dog("Tommy")

# Accessing class attributes

print("Rodger is a {}".format(Rodger.__class__.attr1))

print("Tommy is also a {}".format(Tommy.__class__.attr1))

# Accessing instance attributes

print("My name is {}".format(Rodger.name))

print("My name is {}".format(Tommy.name))























------------------------------------------------END OF OOP---------------------------------------------------------------------------------
enumerate()
- tracks the index of each item in an iterable: enumerate() allows you to loop over a collection of items while keeping track of the current item index
-simplify complex list comprehensions: enumerate() can simplify complex list comprehensions by providing a more efficient way 
to iterate over the values in the list
-improve the performance of your code,enumerate() creates an iterator for the collection, which is more efficient than looping through each item.
**ITERATORS**
File methods in python
.close() Allows the user to close an open file within the IDE
.read() Allows the user to read the contents of an open file and return the number of associated bytes
.readline() Returns the first line of content from an open file
.remove() Allows the user to delete a file if it exists
.rmdir() Allows the user to delete a folder if it exists
.seek() Allows the user to move the location of the file handle's reference point within an open file from one place to another.
.truncate() Allows the user to resize the file to a given number of bytes when the file is accessed through the append mode
.unlink() Allows the user to delete a file path if it exists.
.writable() Allows the user to check if a file is writable or not. 
The function will return True if the file is writable and accessed in append or write mode, and False if it was accessed in read mode.
.write() Adds additional text to a file when the file is opened in append mode.
file = open("myfile.txt", "w") #plaintext file named myfile.txt is created and opened in the write mode
sep='_' sep='/' The separator between the arguments to print() function in Python is space by default,
which can be modified and can be made to any character, integer or string as per your choice.The 'sep' parameter is used to achive this.
pseudocode-detailed yet readable description of what a computer program or algorithm should do eg descriptive variable name
%d - used as a placeholder to specify integer values, decimals, or numbers. It allows us to print numbers within strings or other values. 
The %d operator is put where the integer is to be specified. Floating-point numbers are converted automatically to decimal values.
%x - hexadecimal, %o - octal,%f- float,%s-string
formating strings
The f/F flag (placed before the opening quotation mark).
The .format() method (requires manually adding placeholders)

'''
my_name = 24
print("Hello and welcome{}!" .format(my_name))
print(f'Hello and welukamu {my_name}')
'''
plus-equals operator  x+=y same as x=x+y

Rules for python variables
A variable name must start with a letter or the underscore character. It cannot start with a number.
A variable name can only contain alpha-numeric characters and underscores (A-z, 0-9, and _).
Variable names are case-sensitive (num, Num, and NUM are three different variables).
Variables can’t have spaces or symbols in their names other than an underscore (_)

Python Operators
Arithmetic operators for performing traditional math evaluations such as + - / % * // **
Assignment operators for assigning values to variables such as = += -= /= %= *=
Comparison operators for comparing two values such as == != > >= < <=
Logical operators for combining boolean values such as and or not

Order of operations(Precedence)
NOTE: Items at the same precedence are evaluated left to right. The exception to this is exponentiation, which evaluates right to left
Items in parentheses, ((…)), have the highest level of precedence, expressions within them are evaluated first.
Exponentiation (**)
Multiplication and division operators (*, /, // & %)
Addition and subtraction (+ & -)
Comparison (<, <=, > & >=)
Equality (== & !=)
not
and
or

When python interpreter sees the = assignment operator, three things happen;
the expression on the right side of the symbol is evaluated to obtain a value.
that value is placed in a memory location the address of that location is assigned to the variable on the left of the symbol.
The interpreter keeps track of the number of references to the address, 
and when that number is zero, the memory is released (actually, tagged for “garbage collection”).
Any type of object can go in any address

strings-immutable- dont change
\ backslash, escape character eg It\'s
\n newline \t tab
+ concatenate strings * multiply strings

words that start with uppercase letters come before words that start with lowercase letters, Z is greater than A
Built-in string methods eg split() etc

Python built-in data types
String type: str
Boolean type: bool
Binary types: bytes, bytearray, memoryview
Number types: int, float, complex
Sequence Types: list, range, tuple
Set types: set, frozenset
Dictionary type: dict

sorted(argument like list,dictionaries,strings,tuple), returns a new list
sort()-no arguments, list method only

Floating point arithmetic-Limitations- pythondocs -python.org
---in java, what about py???-----------
linkedlist--pointers
queue--First In First Out(FIFO)
stack-Last In  First  Out(LIFO)
Tree--recursion
hashmaps--like dictionaries

----------------------------------------
OOP
Child can access all parent's data members(class variables and instance variables)and methods, parent **CANNOT** access child's methods
Object belonging to child, also belongs to child's parent(s)--isinstance(obj,class)-check rship between objects and classes
Constructors - special class method for creating and initializing an object instance at that class,in python every class has a 
constructor(its not required to define explicitly)
Method Overriding
Try,except,else,finally?
data hiding using double underscore __ eg __count=0

---dictionaries---
print('Dictionaries')

 

dict_one=dict({'lola':98,'pop':800})

print(type(dict_one))

#dictionary={key:value}

 

#dict_one=None

print(dict_one)

 

dict2={'name':900, 800:99, False:[899,'popo','no_lilo'], 7.777:9568}

print(dict2)

 

cities=('kikuyu','lodwar','machakos','kiambu')

print(type(cities))

 

country='Kenya'

country1='UG'

c_dict=dict.fromkeys(cities,country)

print(c_dict)

 

dict3={True:711,89.99:745,'salo':'togeza','tree':566}

print(len(dict3))

 

dict3.update(salo=999,IS='puncture',togeza=888)

print(dict3)

dd=dict3.popitem()

print(dict3)

print(dd)

 

dict3.clear()

print(dict3)

 

'''

dict3.update(dict2)

del dict3['IS']

print(dict3)

'''

 

 

'''

dict3[True]='yes we can'

print('tree' in dict3)

dict3['tree']='UPDATED?'

print(dict3)

'''

'''

print(dict3.items())

print(dict3.keys())

print(dict3.values())

print(dict3.get('treep'))

'''
-------------------------------------------------------------------------
LIST COMPREHENSION, TUPLES

Tips

List is a collection which is ordered and changeable. Allows duplicate members.

Tuple is a collection which is ordered and unchangeable. Allows duplicate members.

Set is a collection which is unordered, unchangeable*, and unindexed. No duplicate members.

Dictionary is a collection which is ordered** and changeable. No duplicate members.

 

**When choosing a collection type, it is useful to understand the properties of that type. Choosing the right type for a particular data set could mean retention of meaning, and, it could mean an increase in efficiency or security.**

Slicing

first item has index zero

last item index is -1

negative indexing means starting from the end of tuple

[::-1] start from the last backwards/reverse

[::-2] start from the last, skip two(the last inclusive),print next, skip two

[:-1] remove the last item

[-1] print the last item

[x:y] x-included, y-excluded that is, starting from x,upto but not including y

 

Tuples are unchangeable/immutable, meaning that you cannot change, add, or remove items once the tuple is created.(Workaround: convert tuple to a list, update the list,then convert the list back to a tuple)

To add one item to list- .append()

To add more than one item to list-.extend(['itemone','itemtwo'])

 

tp = ("apple", "banana", "cherry","pawpaws","mango","beet","kiwifruit","dragonfruit")

'''

Another way of onverting the tuple to list using list comprehension

tp = ("apple", "banana", "cherry","pawpaws","mango","beet","kiwifruit","dragonfruit")

tpnew=[i for i in tp]

print(tpnew)

'''

tlist=list(tp)

#tlist.append('item') takes one argument,adds only one item at a time

tlist.extend(['junkyfruit','passion','jyuce','healingfruit','camelfruit'])#adds many items

tlist[0]='firstfruit'#added fruit as the first on list at index zero

print(tlist)

#remove item from tuple

tlist.remove('dragonfruit')

#del tlist[1]#remove item using its index

#del tlist-delete the whole list

#remove multiple items from list

tlist=[i for i in tlist if 'a' in i]#list comprehension--i is what will be returned and stored in the variable tlist(it can be any expression, not necessarily the iteration variable),i is the iteration variable in the for loop,tlist is the iterable(the one we will be looping through each time until we reach its end), if is the condition we want to check that determines the value of i that will be returned and stored in our variable: NB CONDITION IS OPTIONAL

#list comprehension--construct new lists from existing ones

#list comprehension syntax : [expression for item in iterable if condition == True]

#tlist=[i for i in tlist if i not in tlist[0:6]]

print(tlist)

tp=tuple(tlist)

print(tp)

print('------------------------------------')

 

#Add tuple to tuple

tpa=('bread','peanut','butter')

tpb=('blueband',)#When creating a tuple with only one item,include a comma after the item

tpc='avocado','mayo','eggs','milk'

tpa+=tpb+tpc

print(tpa)

 

#Construct new list from existing ones using lambda functions

'''

new_letters = list(map(lambda x: x, 'Simplilearn'))

 

print(new_letters)

'''

#print odd numbers upto  not including 15

newlist= [i for i in range(99) if i % 2 !=0]

print(newlist)

 

#numbers divisible by 2 and 3--nested if statement

newlistA= [i for i in range(99) if i % 2 ==0 if i % 3==0]

print(newlistA)

 

#if...else conditionals

'''

cars = ["Nissan", "Mercedes Benz", "Ferrari", "Maserati", "Jeep", "Maruti Suzuki"]

 

cars_with_m=[i if i !='Maserati' else 'MAHINDRA'for i in cars ]

print(cars_with_m)

'''
TUPLES CONT’D

NB: While True --is a looping construct in the Python programming language that allows a block of code to be repeated indefinitely.

#insert item at specific index in a list

newt=[i for i in thistuple]#list comprehension

#newt.insert(1,'fruit')#insert item at a specific index in a list

print(newt)

 

PACKING--assign tuple items to a single variable ,UNPACKING TUPLES--Assign tuple items to individual variables

If the number of variables is less than the number of values, you can add an * to the variable name and the values will be assigned to the variable as a list

If the asterisk is added to another variable name than the last, Python will assign values to the variable until the number of values left matches the number of variables left.

Loop through the index numbers eg

FOR LOOP

fruits = ("apple", "banana", "cherry","KIWI","strawberry","chia seeds","tomato")

for i in range(len(fruits)):

    print(fruits[i])

 

WHILE LOOP

NB: Use the len() function to determine the length of the tuple, then start at 0 and loop your way through the tuple items by referring to their indexes.

fruits = ("apple", "banana", "cherry","KIWI","strawberry","chia seeds","tomato")

counter=0

while counter<len(fruits):

    print(fruits[counter])

    counter+=1

 

Indefinite loop eg

counter=7

while counter==len(fruits):

    print(fruits[counter-1])

    #break --stops the loop from looping forever

    #counter+=1 --helps stop the loop from looping forever

Join two or more tuples +

multiply the content of a tuple a given number of times, you can use the * operator *

Tuple Methods

count()  Returns the number of times a specified value occurs in a tuple

index()   Searches the tuple for a specified value and returns the position of where it was found
--------------------------------------------------------------------------
Algorithms

Algorithms--optimization,efficiency

**Big O Notation ...etc

**breadth first search

search

encryption

principles

input>set of Instructions>execution>output>>termination of program

Simple recursive algorithms--iteration, recursion

Algorithms within data structures

DS-Lists,stacks,trees,hastables,heaps,linked lists,queues,**arrays--types of arrays

stack,queue,priority queue

Search and sort

Linear/sequential search

Binary search--usually done in a sorted array

Sorting-bubble sort???--outdated???

Insertion sort

**Linkedlists**

-Traverse a linked list

-Search a list

-Insert header or tail

-Delete a node

-headers, nodes,tail

**Doubly linked lists**

**Hash tables- Associative arrays,hash functions,key/value pairs,collision,chaining,highly efficient--Robin Karp algorithm**

Divide and conquer--implemented recursively

-Function optimization

-**Merge sort-top down,bottom up**

-Strassen algorithm--matrix multiplication

Greedy Algorithms-fractional knapsack,fibonacci

Brute force algorithm

Dynamic Programming-dynamic programming languages, dynamic programming methodology

*Python is strongly typed- the interpreter keeps track of all variable types.

*Python can be very dynamic, as it rarely uses this information to limit variable usage.

-Principal of optimality

break problem down into smaller sub-problems

solving recursively

using optimal solutions to construct optimal solutions for the original problem

-recursion

top/down(with memoization)

bottom/up(with tabulation)

Python pass Statement--used as a placeholder for future code,NB:functions,classes,if statement and loops cannot be empty
*******************************
Linear data structures- Nodes, linkedlists,stacks,queues
Technical Interview Practice with python(codecademy)
*******************************

--------------------------------------------------------------------------------
Loops- for loop,while loop, nested loop
Types of iteration in python
Indefinite iteration-where the number of times the loop is executed depends on how many times a condition is met
Definite iteration-where the number of times the loop will be executed is defined in advance(usually based on the collection size)
WHILE Loop
-While loop is used to execute a block of code repeatedly until given boolean condition evaluated to False. 
-If we write while True then the loop will run forever.
-The condition of a while loop is always checked first before the block of code runs. If the condition is not met initially,
then the code block will never run.
-requires a variable to track the condition of the loop to start and stop.

while loop:lists
ingredients = ["milk", "sugar", "vanilla extract", "dough", "chocolate"]
length=len(ingredients)
index=0
while index<length:
    print(ingredients[index])
	index+=1
print('END OF LOOP!!')

FOR Loop
syntax
for iteration variable in iterable:

Nested loop
output of outer loop is the input of the inner nested loop--Nested loops can be used to access items of lists which are inside other lists.
The item selected from the outer loop can be used as the list for the inner loop to iterate over eg
groups = [["Jobs", "Gates"], ["Newton", "Euclid"], ["Einstein", "Feynman"]]
for i in groups:
    for j in i:
	    print(j)

Indentation: If the first level of code block fails to meet condition, the interpreter proceeds to the next level of indentation
Indentation in Python is used to identify lines of code which are executed together.

Break keyword. 
the break statement will terminate the execution of the for loop. 
It does not allow for the execution of any additional code in the loop if it exists.
The point at which the indentation ends identifies the code that is NOT part of the loop.
-the break keyword escapes the loop, regardless of the iteration number
-Once break executes, the program will continue to execute after the loop
numbers = [0, 254, 2, -1, 3]
for i in numbers:#i is the iteration variable,numbers is the iterable
    if i<0:#if condition not met,execute next level of indentation(print(i) in this case)
        print('Negative number found',i)
        break#escapes the loop/moves out of the loop, loop will not execute anymore
    print(i)

Continue Keyword
The continue keyword is used inside a loop to skip the remaining code inside the loop code block and begin the next loop iteration.
big_number_list = [1, 2, -1, 4, -5, 5, 2, -9]
for i in big_number_list:
    if i<0:
        continue#do not execute any other code inside the loop,execute the next loop iteration
    print(i)#same level indentation as if,executes if 'if' condition is not met
DIFF BETWEEN BREAK AND CONTINUE
The continue statement interrupts the execution of a loop and causes the loop to start the next iteration. 
Any code following the continue is not executed but the loop will continue on starting with the next iteration. 
The break statement will terminate the execution of the loop.
No further code in the loop will execute and the program will resume execution at the next statement following the end of the loop.

**Transpose of a matrix-new matrix obtained by interchanging the rows and columns of the original matrix
transposed = []
matrix = [[1, 2, 3, 4], [4, 5, 6, 8]]
for i in range(len(matrix[0])):
    transposed1=[]
    for k in matrix:
        transposed1.append(k[i])
    transposed.append(transposed1)
print(transposed)

#To revert to the original matrix
#variable transposed has 4 rows and 2 columns
#for i in range(2) executes first
#k[i] for k in transposed executes second
reverted1=[[k[i] for k in transposed] for i in range(2)]
print(reverted1)
NB:every list comprehension can be rewritten in for loop, but every for loop can’t be rewritten in the form of list comprehension.

if...else with list comprehension
obj = ["Even" if i%2==0 else "Odd" for i in range(10)]
print(obj)
Explained:list comprehension will check the 10 numbers from 0 to 9. If i is divisible by 2, then Even is appended to the obj list. 
If not, Odd is appended
----------------------------------------------------------------------------
Syntax on whether or not else clause is used in list comprehension eg 
numbers = [2, -1, 79, 33, -45]

no_if   = [num * 2 for num in numbers]
if_only = [num * 2 for num in numbers if num < 0]
if_else = [num * 2 if num < 0 else num * 3 for num in numbers]
-----------------------------------------------------------------------------
PRINTING IN REVERSE--1. Use reverse(name_of list)2.How does this code work--i dont get it?
myList = list(range(10))
print(myList)

k = []
myList_length = len(myList)

for i in range(myList_length):
    k.append(myList[myList_length-1-i])#particularly here!!!!
print(k)
-------------------------------------------------------------------------------
FUNCTIONS
-Code reuse
-def keyword--beginning of a function/function header
def function_name():
    #function tasks go here
--Types of arguments--positional arguments,keyword arguments,default arguments
-Keyword arguments must be passed after positional arguments
*args--tuple--The asterisk, known in this context as the “packing operator”, packs the arguments into a tuple stored in args
**kwargs--dictionary--the double asterisk is a packing operator that produces a dictionary rather than a tuple
--functions can be called with an arbitrary/random number of keyword arguments. In this case, a special parameter **kwargs is passed in, 
where the double asterisk is a packing operator that produces a dictionary rather than a tuple.
The parameter name and value of each keyword argument are packed as a key-value pair stored in kwargs
def north_american_capitals(**kwargs):
  for i in kwargs:#i--key, kwargs--dictionary
    #print(kwargs)
    print(i + ": " + kwargs[i])#kwargs[i]--retrieves value for the key i 

similar to
def func1(**kwargs):
    for i in kwargs:
        print(i,':'+ kwargs[i])
func1(key1='australia',key2='jamaica',key3='turkana',key4='mandera')

north_american_capitals(canada="Ottawa", us="Washington D.C.", mexico="Mexico City",dubai="dhubai")
-When defining a function, both forms of argument packing can be used. However, args must always precede kwargs
-Argument unpacking--pass positional or keyword arguments dynamically

Anonymous Functions- Defines a function without a name using the lambda keyword.

Higher Order Functions
Predicate--a function that returns a boolean value
In Python, functions are treated as first-class objects, meaning they can be assigned to variables, stored in data structures, and passed to or returned from other functions
Functions are considered to be “higher-order” values because they can be used as parameters or return values for other functions eg filter()

25.01.2024

functions cont'd

-When there is a result from a function that is stored in a variable, it is called a returned function value.

-return passes the variable back to the function caller

Stacks-Last In First Out(LIFO). Stacks are less flexible than lists, but are easier to implement, and more efficient (for those operations they can do). Given a stack, the accessible element of the stack is called the top element. Elements are not said to be inserted; they are pushed onto the stack.

Queues- First In First Out(FIFO).

 
STRINGS

Slicing

string[start:end:step]

start defaults to 0 and gives the initial position the slice will start from.

end defaults to -1 and is the position where the slicing will end.

step defaults to 1 and indicates the number of steps to take in between indexes.

name='Code Ninja'

name[::2]#from reverse,print that last character,skip two(the printed one included),print next,skip two,print next,skip two...

#output:anNeo


.find()The string method .find() can also be used to find a subset. It returns the index of the first occurrence of the substring. 
If the substring is not found, it returns -1. 

name='codetechbabes'

p=name[0:7:2]

#output:cdtc

Example code

Concatenates the last three letters of each and returns them as a string

first_name = "Reiko"

last_name = "Matsuki"

 

def password_generator(first_name,last_name):

  nw=first_name[len(first_name)-3:]+last_name[len(last_name)-3:]

  return nw

temp_password=password_generator(first_name,last_name)

print(temp_password)

#output:ikouki

 

Get the middle character of a string

**floor division, //:used to divide two numbers and get the result in which the quotient is rounded down to the nearest integer value

#FOR STRINGS WITH EVEN NO. OF CHARACTERS

first_name = "Matsukip"

#left character

w=(len(first_name)-1)//2

print(first_name[w])

 

#right character

z=len(first_name)//2

print(first_name[z])

 

#FOR STRINGS WITH ODD NO. OF CHARACTERS

first_name = "Matsuip"

middle=len(first_name)//2

print(first_name[middle])

 

COMPARING STRINGS

== Equal Returns True if two strings are equal.

!= Not equal Returns True if two strings are not equal.

<  Less than  Returns True if the left string is lexically prior the right string.

> Greater than Returns True is the left string comes lexically after the right string.

<= Less than or equal to Returns True if the left string is equal to or lexically prior to the right string.

>= Greater than or equal to Returns True if the left string is equal to or comes lexically after the right string.

**Negative indices

**Strings are immutable--This means that we cannot change a string once it is created. We can use it to create other strings, but we cannot change the string itself.This property, generally, is known as mutability.When concatenating two strings in Python, rather than updating a string, it creates an entirely new string in memory.

**Because strings are lists, that means we can iterate through a string using for or while loops

ESCAPE CHARACTERS

Backslash \ tells Python to treat the character that follows as a literal character, not a special one.By adding a backslash in front of the special character we want to escape, \", we can include it in a string.

-----NEW-----
yield keyword--FIBONACCI SERIES!!!
-yield suspends the function’s execution and returns the value specified
-the yield statement retains the state of the function and will resume where it left off on the next function call 
(i.e. execution resumes after the last yield statement). This way, the function can produce a number of values over time.
generator functions
generator object
iterator

 

---------------------RESOURCES-----------------------------------------------------
thetesttribe.com --testautomation



-------------------------------END OF RESOURCES------------------------------------
generator functions
coroutine functions
-native coroutine functions
-native coroutine
-generator based co-routine function
-coroutine object
Coroutine generators
Async def,async,await keywords
decorator
**Use generators,comprehensions,iterators instead of lists and tuples---why is this so?
**an API endpoint is a specific location within an API that accepts requests and sends back responses.
It's a way for different systems and applications to communicate with each other, 
by sending and receiving information and instructions via the endpoint.

***Rest api with flask and python - https://github.com/tecladocode/rest-apis-flask-python ***
E-BOOK: https://rest-apis-flask.teclado.com/docs/course_intro/
cs50: https://cs50.harvard.edu/python/2022/weeks/0/

Reference vs copy?
Pass by value vs pass by reference
Anonymous variables _
code for matrices--rows and columns--transposing???
nested loops
programmingexpert.io--tech with tim-YT
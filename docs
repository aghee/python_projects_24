#PEP8--comments max 79 characters,code max 72 characters
#Customized simple explanations collected as i learn python
_init_() method -python calls this method by default everytime you create an object, it creates space in computer memory for the object
Any time a .py file is run and interpreted, certain variables are set up and linked with the file. 
This includes __main__ environment variable, which is assigned as the file’s __name__ variable.
File methods in python
.close() Allows the user to close an open file within the IDE
.read() Allows the user to read the contents of an open file and return the number of associated bytes
.readline() Returns the first line of content from an open file
.remove() Allows the user to delete a file if it exists
.rmdir() Allows the user to delete a folder if it exists
.seek() Allows the user to move the location of the file handle's reference point within an open file from one place to another.
.truncate() Allows the user to resize the file to a given number of bytes when the file is accessed through the append mode
.unlink() Allows the user to delete a file path if it exists.
.writable() Allows the user to check if a file is writable or not. 
The function will return True if the file is writable and accessed in append or write mode, and False if it was accessed in read mode.
.write() Adds additional text to a file when the file is opened in append mode.
file = open("myfile.txt", "w") #plaintext file named myfile.txt is created and opened in the write mode
sep='_' sep='/' The separator between the arguments to print() function in Python is space by default,
which can be modified and can be made to any character, integer or string as per your choice.The 'sep' parameter is used to achive this.
pseudocode-detailed yet readable description of what a computer program or algorithm should do eg descriptive variable name
%d - used as a placeholder to specify integer values, decimals, or numbers. It allows us to print numbers within strings or other values. 
The %d operator is put where the integer is to be specified. Floating-point numbers are converted automatically to decimal values.
%x - hexadecimal, %o - octal,%f- float,%s-string
formating strings
The f/F flag (placed before the opening quotation mark).
The .format() method (requires manually adding placeholders)

'''
my_name = 24
print("Hello and welcome{}!" .format(my_name))
print(f'Hello and welukamu {my_name}')
'''
plus-equals operator  x+=y same as x=x+y

Rules for python variables
A variable name must start with a letter or the underscore character. It cannot start with a number.
A variable name can only contain alpha-numeric characters and underscores (A-z, 0-9, and _).
Variable names are case-sensitive (num, Num, and NUM are three different variables).
Variables can’t have spaces or symbols in their names other than an underscore (_)

Python Operators
Arithmetic operators for performing traditional math evaluations such as + - / % * // **
Assignment operators for assigning values to variables such as = += -= /= %= *=
Comparison operators for comparing two values such as == != > >= < <=
Logical operators for combining boolean values such as and or not

Order of operations(Precedence)
NOTE: Items at the same precedence are evaluated left to right. The exception to this is exponentiation, which evaluates right to left
Items in parentheses, ((…)), have the highest level of precedence, expressions within them are evaluated first.
Exponentiation (**)
Multiplication and division operators (*, /, // & %)
Addition and subtraction (+ & -)
Comparison (<, <=, > & >=)
Equality (== & !=)
not
and
or

When python interpreter sees the = assignment operator, three things happen;
the expression on the right side of the symbol is evaluated to obtain a value.
that value is placed in a memory location the address of that location is assigned to the variable on the left of the symbol.
The interpreter keeps track of the number of references to the address, 
and when that number is zero, the memory is released (actually, tagged for “garbage collection”).
Any type of object can go in any address

strings-immutable- dont change
\ backslash, escape character eg It\'s
\n newline \t tab
+ concatenate strings * multiply strings

words that start with uppercase letters come before words that start with lowercase letters, Z is greater than A
Built-in string methods eg split() etc

Python built-in data types
String type: str
Boolean type: bool
Binary types: bytes, bytearray, memoryview
Number types: int, float, complex
Sequence Types: list, range, tuple
Set types: set, frozenset
Dictionary type: dict

sorted(argument like list,dictionaries,strings,tuple), returns a new list
sort()-no arguments, list method only

Floating point arithmetic-Limitations- pythondocs -python.org
---in java, what about py???-----------
linkedlist--pointers
queue--First In First Out(FIFO)
stack-Last In  First  Out(LIFO)
Tree--recursion
hashmaps--like dictionaries

----------------------------------------
OOP
Child can access all parent's data members(class variables and instance variables)and methods, parent **CANNOT** access child's methods
Object belonging to child, also belongs to child's parent(s)--isinstance(obj,class)-check rship between objects and classes
Constructors - special class method for creating and initializing an object instance at that class,in python every class has a 
constructor(its not required to define explicitly)
Method Overriding
Try,except,else,finally?
data hiding using double underscore __ eg __count=0

---dictionaries---
print('Dictionaries')

 

dict_one=dict({'lola':98,'pop':800})

print(type(dict_one))

#dictionary={key:value}

 

#dict_one=None

print(dict_one)

 

dict2={'name':900, 800:99, False:[899,'popo','no_lilo'], 7.777:9568}

print(dict2)

 

cities=('kikuyu','lodwar','machakos','kiambu')

print(type(cities))

 

country='Kenya'

country1='UG'

c_dict=dict.fromkeys(cities,country)

print(c_dict)

 

dict3={True:711,89.99:745,'salo':'togeza','tree':566}

print(len(dict3))

 

dict3.update(salo=999,IS='puncture',togeza=888)

print(dict3)

dd=dict3.popitem()

print(dict3)

print(dd)

 

dict3.clear()

print(dict3)

 

'''

dict3.update(dict2)

del dict3['IS']

print(dict3)

'''

 

 

'''

dict3[True]='yes we can'

print('tree' in dict3)

dict3['tree']='UPDATED?'

print(dict3)

'''

'''

print(dict3.items())

print(dict3.keys())

print(dict3.values())

print(dict3.get('treep'))

'''
-------------------------------------------------------------------------
LIST COMPREHENSION, TUPLES

Tips

List is a collection which is ordered and changeable. Allows duplicate members.

Tuple is a collection which is ordered and unchangeable. Allows duplicate members.

Set is a collection which is unordered, unchangeable*, and unindexed. No duplicate members.

Dictionary is a collection which is ordered** and changeable. No duplicate members.

 

**When choosing a collection type, it is useful to understand the properties of that type. Choosing the right type for a particular data set could mean retention of meaning, and, it could mean an increase in efficiency or security.**

Slicing

first item has index zero

last item index is -1

negative indexing means starting from the end of tuple

[::-1] start from the last backwards/reverse

[::-2] start from the last, skip two(the last inclusive),print next, skip two

[:-1] remove the last item

[-1] print the last item

[x:y] x-included, y-excluded that is, starting from x,upto but not including y

 

Tuples are unchangeable/immutable, meaning that you cannot change, add, or remove items once the tuple is created.(Workaround: convert tuple to a list, update the list,then convert the list back to a tuple)

To add one item to list- .append()

To add more than one item to list-.extend(['itemone','itemtwo'])

 

tp = ("apple", "banana", "cherry","pawpaws","mango","beet","kiwifruit","dragonfruit")

'''

Another way of onverting the tuple to list using list comprehension

tp = ("apple", "banana", "cherry","pawpaws","mango","beet","kiwifruit","dragonfruit")

tpnew=[i for i in tp]

print(tpnew)

'''

tlist=list(tp)

#tlist.append('item') takes one argument,adds only one item at a time

tlist.extend(['junkyfruit','passion','jyuce','healingfruit','camelfruit'])#adds many items

tlist[0]='firstfruit'#added fruit as the first on list at index zero

print(tlist)

#remove item from tuple

tlist.remove('dragonfruit')

#del tlist[1]#remove item using its index

#del tlist-delete the whole list

#remove multiple items from list

tlist=[i for i in tlist if 'a' in i]#list comprehension--i is what will be returned and stored in the variable tlist(it can be any expression, not necessarily the iteration variable),i is the iteration variable in the for loop,tlist is the iterable(the one we will be looping through each time until we reach its end), if is the condition we want to check that determines the value of i that will be returned and stored in our variable: NB CONDITION IS OPTIONAL

#list comprehension--construct new lists from existing ones

#list comprehension syntax : [expression for item in iterable if condition == True]

#tlist=[i for i in tlist if i not in tlist[0:6]]

print(tlist)

tp=tuple(tlist)

print(tp)

print('------------------------------------')

 

#Add tuple to tuple

tpa=('bread','peanut','butter')

tpb=('blueband',)#When creating a tuple with only one item,include a comma after the item

tpc='avocado','mayo','eggs','milk'

tpa+=tpb+tpc

print(tpa)

 

#Construct new list from existing ones using lambda functions

'''

new_letters = list(map(lambda x: x, 'Simplilearn'))

 

print(new_letters)

'''

#print odd numbers upto  not including 15

newlist= [i for i in range(99) if i % 2 !=0]

print(newlist)

 

#numbers divisible by 2 and 3--nested if statement

newlistA= [i for i in range(99) if i % 2 ==0 if i % 3==0]

print(newlistA)

 

#if...else conditionals

'''

cars = ["Nissan", "Mercedes Benz", "Ferrari", "Maserati", "Jeep", "Maruti Suzuki"]

 

cars_with_m=[i if i !='Maserati' else 'MAHINDRA'for i in cars ]

print(cars_with_m)

'''
TUPLES CONT’D

NB: While True --is a looping construct in the Python programming language that allows a block of code to be repeated indefinitely.

#insert item at specific index in a list

newt=[i for i in thistuple]#list comprehension

#newt.insert(1,'fruit')#insert item at a specific index in a list

print(newt)

 

PACKING--assign tuple items to a single variable ,UNPACKING TUPLES--Assign tuple items to individual variables

If the number of variables is less than the number of values, you can add an * to the variable name and the values will be assigned to the variable as a list

If the asterisk is added to another variable name than the last, Python will assign values to the variable until the number of values left matches the number of variables left.

Loop through the index numbers eg

FOR LOOP

fruits = ("apple", "banana", "cherry","KIWI","strawberry","chia seeds","tomato")

for i in range(len(fruits)):

    print(fruits[i])

 

WHILE LOOP

NB: Use the len() function to determine the length of the tuple, then start at 0 and loop your way through the tuple items by referring to their indexes.

fruits = ("apple", "banana", "cherry","KIWI","strawberry","chia seeds","tomato")

counter=0

while counter<len(fruits):

    print(fruits[counter])

    counter+=1

 

Indefinite loop eg

counter=7

while counter==len(fruits):

    print(fruits[counter-1])

    #break --stops the loop from looping forever

    #counter+=1 --helps stop the loop from looping forever

Join two or more tuples +

multiply the content of a tuple a given number of times, you can use the * operator *

Tuple Methods

count()  Returns the number of times a specified value occurs in a tuple

index()   Searches the tuple for a specified value and returns the position of where it was found
--------------------------------------------------------------------------
Algorithms

Algorithms--optimization,efficiency

**Big O Notation ...etc

**breadth first search

search

encryption

principles

input>set of Instructions>execution>output>>termination of program

Simple recursive algorithms--iteration, recursion

Algorithms within data structures

DS-Lists,stacks,trees,hastables,heaps,linked lists,queues,**arrays--types of arrays

stack,queue,priority queue

Search and sort

Linear/sequential search

Binary search--usually done in a sorted array

Sorting-bubble sort???--outdated???

Insertion sort

**Linkedlists**

-Traverse a linked list

-Search a list

-Insert header or tail

-Delete a node

-headers, nodes,tail

**Doubly linked lists**

**Hash tables- Associative arrays,hash functions,key/value pairs,collision,chaining,highly efficient--Robin Karp algorithm**

Divide and conquer--implemented recursively

-Function optimization

-**Merge sort-top down,bottom up**

-Strassen algorithm--matrix multiplication

Greedy Algorithms-fractional knapsack,fibonacci

Brute force algorithm

Dynamic Programming-dynamic programming languages, dynamic programming methodology

*Python is strongly typed- the interpreter keeps track of all variable types.

*Python can be very dynamic, as it rarely uses this information to limit variable usage.

-Principal of optimality

break problem down into smaller sub-problems

solving recursively

using optimal solutions to construct optimal solutions for the original problem

-recursion

top/down(with memoization)

bottom/up(with tabulation)

Python pass Statement--used as a placeholder for future code,NB:functions,classes,if statement and loops cannot be empty
*******************************
Linear data structures- Nodes, linkedlists,stacks,queues
Technical Interview Practice with python(codecademy)
*******************************

--------------------------------------------------------------------------------
Loops- for loop,while loop, nested loop
Types of iteration in python
Indefinite iteration-where the number of times the loop is executed depends on how many times a condition is met
Definite iteration-where the number of times the loop will be executed is defined in advance(usually based on the collection size)
WHILE Loop
-While loop is used to execute a block of code repeatedly until given boolean condition evaluated to False. 
-If we write while True then the loop will run forever.
-The condition of a while loop is always checked first before the block of code runs. If the condition is not met initially,
then the code block will never run.
-requires a variable to track the condition of the loop to start and stop.

while loop:lists
ingredients = ["milk", "sugar", "vanilla extract", "dough", "chocolate"]
length=len(ingredients)
index=0
while index<length:
    print(ingredients[index])
	index+=1
print('END OF LOOP!!')

FOR Loop
syntax
for iteration variable in iterable:

Nested loop
output of outer loop is the input of the inner nested loop--Nested loops can be used to access items of lists which are inside other lists.
The item selected from the outer loop can be used as the list for the inner loop to iterate over eg
groups = [["Jobs", "Gates"], ["Newton", "Euclid"], ["Einstein", "Feynman"]]
for i in groups:
    for j in i:
	    print(j)

Indentation: If the first level of code block fails to meet condition, the interpreter proceeds to the next level of indentation
Indentation in Python is used to identify lines of code which are executed together.

Break keyword. 
the break statement will terminate the execution of the for loop. 
It does not allow for the execution of any additional code in the loop if it exists.
The point at which the indentation ends identifies the code that is NOT part of the loop.
-the break keyword escapes the loop, regardless of the iteration number
-Once break executes, the program will continue to execute after the loop
numbers = [0, 254, 2, -1, 3]
for i in numbers:#i is the iteration variable,numbers is the iterable
    if i<0:#if condition not met,execute next level of indentation(print(i) in this case)
        print('Negative number found',i)
        break#escapes the loop/moves out of the loop, loop will not execute anymore
    print(i)

Continue Keyword
The continue keyword is used inside a loop to skip the remaining code inside the loop code block and begin the next loop iteration.
big_number_list = [1, 2, -1, 4, -5, 5, 2, -9]
for i in big_number_list:
    if i<0:
        continue#do not execute any other code inside the loop,execute the next loop iteration
    print(i)#same level indentation as if,executes if 'if' condition is not met
DIFF BETWEEN BREAK AND CONTINUE
The continue statement interrupts the execution of a loop and causes the loop to start the next iteration. 
Any code following the continue is not executed but the loop will continue on starting with the next iteration. 
The break statement will terminate the execution of the loop.
No further code in the loop will execute and the program will resume execution at the next statement following the end of the loop.

**Transpose of a matrix-new matrix obtained by interchanging the rows and columns of the original matrix
transposed = []
matrix = [[1, 2, 3, 4], [4, 5, 6, 8]]
for i in range(len(matrix[0])):
    transposed1=[]
    for k in matrix:
        transposed1.append(k[i])
    transposed.append(transposed1)
print(transposed)

#To revert to the original matrix
#variable transposed has 4 rows and 2 columns
#for i in range(2) executes first
#k[i] for k in transposed executes second
reverted1=[[k[i] for k in transposed] for i in range(2)]
print(reverted1)
NB:every list comprehension can be rewritten in for loop, but every for loop can’t be rewritten in the form of list comprehension.

if...else with list comprehension
obj = ["Even" if i%2==0 else "Odd" for i in range(10)]
print(obj)
Explained:list comprehension will check the 10 numbers from 0 to 9. If i is divisible by 2, then Even is appended to the obj list. 
If not, Odd is appended
----------------------------------------------------------------------------
Syntax on whether or not else clause is used in list comprehension eg 
numbers = [2, -1, 79, 33, -45]

no_if   = [num * 2 for num in numbers]
if_only = [num * 2 for num in numbers if num < 0]
if_else = [num * 2 if num < 0 else num * 3 for num in numbers]
-----------------------------------------------------------------------------
PRINTING IN REVERSE--1. Use reverse(name_of list)2.How does this code work--i dont get it?
myList = list(range(10))
print(myList)

k = []
myList_length = len(myList)

for i in range(myList_length):
    k.append(myList[myList_length-1-i])#particularly here!!!!
print(k)
-------------------------------------------------------------------------------
FUNCTIONS
-Code reuse
-def keyword--beginning of a function/function header
def function_name():
    #function tasks go here
--Types of arguments--positional arguments,keyword arguments,default arguments
-Keyword arguments must be passed after positional arguments
*args--tuple--The asterisk, known in this context as the “packing operator”, packs the arguments into a tuple stored in args
**kwargs--dictionary--the double asterisk is a packing operator that produces a dictionary rather than a tuple
--functions can be called with an arbitrary/random number of keyword arguments. In this case, a special parameter **kwargs is passed in, 
where the double asterisk is a packing operator that produces a dictionary rather than a tuple.
The parameter name and value of each keyword argument are packed as a key-value pair stored in kwargs
def north_american_capitals(**kwargs):
  for i in kwargs:#i--key, kwargs--dictionary
    #print(kwargs)
    print(i + ": " + kwargs[i])#kwargs[i]--retrieves value for the key i 

similar to
def func1(**kwargs):
    for i in kwargs:
        print(i,':'+ kwargs[i])
func1(key1='australia',key2='jamaica',key3='turkana',key4='mandera')

north_american_capitals(canada="Ottawa", us="Washington D.C.", mexico="Mexico City",dubai="dhubai")
-When defining a function, both forms of argument packing can be used. However, args must always precede kwargs
-Argument unpacking--pass positional or keyword arguments dynamically

Anonymous Functions- Defines a function without a name using the lambda keyword.

Higher Order Functions
Predicate--a function that returns a boolean value
In Python, functions are treated as first-class objects, meaning they can be assigned to variables, stored in data structures, and passed to or returned from other functions
Functions are considered to be “higher-order” values because they can be used as parameters or return values for other functions eg filter()

-----NEW-----
yield keyword--FIBONACCI SERIES!!!
-yield suspends the function’s execution and returns the value specified
-the yield statement retains the state of the function and will resume where it left off on the next function call 
(i.e. execution resumes after the last yield statement). This way, the function can produce a number of values over time.
generator functions
generator object
iterator

 

---------------------RESOURCES-----------------------------------------------------
thetesttribe.com --testautomation



-------------------------------END OF RESOURCES------------------------------------